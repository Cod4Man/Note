# 杂

## 1. 包装类

### 1.1 比较大小时的自动拆箱

```java
public static void main(String[] args){
    Integer i1 = new Integer(4);
    Integer i2 = new Integer(6);
    Integer i3 = new Integer(10);
    Integer i4 = new Integer(10);
    System.out.print(i3 == i4);//false, 比较的是地址
    System.out.print(i3 == i1+i2);//true
    // 解析
    // 对象无法进行“+”操作，所以包装类i1和i2会先拆箱成int，然后进行“+”操作，则右边结果为(int)10，而包装类和基本数据类型比较也会先拆箱，所以左边为（int）10，所以比较的是大小，而非地址值。
}
```

### 1.2 Integer的常量池[-128, 127]

```java
public static void main(String[] args)
{

    Integer i1 = new Integer(66);
    Integer i2 = new integer(66);
    Integer i3 = 66; // Integer = int，会自动装箱
    Integer i4 = 66;
    Integer i5 = 150;
    Integer i6 = 150;
    System.out.println(i1 == i2);//false
    System.out.println(i3 == i4);//true, 常量池[-128, 127]区间范围，取得是常量池，地址同一个
    System.out.println(i5 == i6);//false， 超出常量池范围，创建新对象
}


/*
*　Integer源码
*/
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

## 2. String

### 2.1 String常量池

- String由final修饰，不可被继承。
- String创建对象的两种方式

```java
//1、
String str = new String("abcd"); 
// 使用 new 创建的对象，存放在堆中。每次调用都会创建一个新的对象。
 
//2、
String str = "abcd";
// 先在栈上创建一个 String 类的对象引用变量 str，然后通过符号引用去字符串常量池中找有没有 “abcd”，如果没有，则将“abcd”存放到字符串常量池中，并将栈上的 str 变量引用指向常量池中的“abcd”。如果常量池中已经有“abcd”了，则不会再常量池中创建“abcd”，而是直接将 str 引用指向常量池中的“abcd”。
```

### 2.2 关于字符串 + 号连接问题(实质是StringBuilder.append) 

对于字符串常量的 + 号连接，在程序编译期，JVM就会**将其优化为 + 号连接后的值**。所以在**编译期其字符串常量的值就确定了**。 

```java
    String a = "a1";   
    String b = "a" + 1;   // 编译后=》String b = “a1”
    System.out.println((a == b)); //result = true  
     
    String a = "a3.4";   
    String b = "a" + 3.4;  // 编译后=》String b = “a3.4” 
    System.out.println((a == b)); //result = true 

	String a = "a";
	String b = "ab";
	String c = a + "b"; // 反编译后发现， String c = (new StringBuilder()).append(a).append("b").toString(); 说明c对象是new出来的，而不是去常量池创建
	System.out.println((b == c)); //result = false 
	// c在编译期间无法确认a对象的值(是否会变化)，因此编译期间无法确认c的值。
	// 会在运行期间，动态的分配并将连接后的新地址复制给c。
```

因此，尽量不要在for中使用“+”符号操作字符串，而是**使用StringBuffer/StringBuilder去替换**。

上面demo中，`String c = a + "b"` , c在编译期间无法得知a的值，a可以用**final修饰**（这样a就是一个常量，编译期间就能获得它的值，就像d一样）。

### 2.3 intern()

调用 intern 方法。

从JDK7开始，**如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在<u>堆上的地址引用复制到常量池</u>。**(intern不再拷贝字符串到常量池，而是只有堆的地址引用ef0010, 相比之前，可以节省空间) 

![1615098869302](E:\SoftwareNote\面试准备\JAVASE\img\String的intern方法.png)

```java
public static void main(String[] args){
    String str0 = "57tongcheng";
    String str1 = new String("58tongcheng2");
    String str2 = new StringBuilder("58").append("tongcheng").toString();
    String str3 = new StringBuilder("ja").append("va").toString();
    String str4 = new StringBuilder("57").append("tongcheng").toString();
    System.out.println(str0 == str0.intern()); // true, str0 = "57tongcheng"是创建在字符串常量池，str0.intern指向的是"57tongcheng"首次引用的地址，而就是str0的地址，即常量池地址
    System.out.println(str1 == str1.intern()); // false， new String是创建对象(并且同时在常量池加入该字符串)，intern返回的是字符串常量池中的地址，new的是另外一个地址。（new创建2个地址：new+常量池）
    System.out.println(str2 == str2.intern()); // true， "58tongcheng"再常量池没有，所以intern指向str2的对象地址
    System.out.println(str3 == str3.intern()); // false, "java"字符串在常量池已有()，intern指向第一次的对象引用地址
    System.out.println(str4 == str4.intern()); // false，"57tongcheng"str0已经加入到常量池，所以str4.intern指向的是str0的地址，也就是常量池地址
}
```

- "java"常量池的由来

```java
public final class System {

    /* register the natives via the static initializer.
     *
     * VM will invoke the initializeSystemClass method to complete
     * the initialization for this class separated from clinit.
     * Note that to use properties set by the VM, see the constraints
     * described in the initializeSystemClass method.
     */
    private static native void registerNatives();
    static {
        registerNatives();
    }
    
    
    private static void initializeSystemClass() {

        // VM might invoke JNU_NewStringPlatform() to set those encoding
        // sensitive properties (user.home, user.name, boot.class.path, etc.)
        // during "props" initialization, in which it may need access, via
        // System.getProperty(), to the related system encoding property that
        // have been initialized (put into "props") at early stage of the
        // initialization. So make sure the "props" is available at the
        // very beginning of the initialization and all system properties to
        // be put into it directly.
        props = new Properties();
        initProperties(props);  // initialized by the VM

        // There are certain system configurations that may be controlled by
        // VM options such as the maximum amount of direct memory and
        // Integer cache size used to support the object identity semantics
        // of autoboxing.  Typically, the library will obtain these values
        // from the properties set by the VM.  If the properties are for
        // internal implementation use only, these properties should be
        // removed from the system properties.
        //
        // See java.lang.Integer.IntegerCache and the
        // sun.misc.VM.saveAndRemoveProperties method for example.
        //
        // Save a private copy of the system properties object that
        // can only be accessed by the internal implementation.  Remove
        // certain system properties that are not intended for public access.
        sun.misc.VM.saveAndRemoveProperties(props);


        lineSeparator = props.getProperty("line.separator");
        sun.misc.Version.init(); // 这里
    }
}
    
public class Version {
    private static final String launcher_name = "java"; // 这里，“java”.intern指向的是launcher_name
    private static final String java_version = "1.8.0_112";
    private static final String java_runtime_name = "Java(TM) SE Runtime Environment";
    private static final String java_profile_name = "";
    private static final String java_runtime_version = "1.8.0_112-b15";
    private static boolean versionsInitialized;
}
    
    
    
    
```





