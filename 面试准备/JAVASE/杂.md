# 杂

## 1. 包装类

### 1.1 比较大小时的自动拆箱

```java
public static void main(String[] args){
    Integer i1 = new Integer(4);
    Integer i2 = new Integer(6);
    Integer i3 = new Integer(10);
    Integer i4 = new Integer(10);
    System.out.print(i3 == i4);//false, 比较的是地址
    System.out.print(i3 == i1+i2);//true
    // 解析
    // 对象无法进行“+”操作，所以包装类i1和i2会先拆箱成int，然后进行“+”操作，则右边结果为(int)10，而包装类和基本数据类型比较也会先拆箱，所以左边为（int）10，所以比较的是大小，而非地址值。
}
```

### 1.2 Integer的常量池[-128, 127]

```java
public static void main(String[] args)
{

    Integer i1 = new Integer(66);
    Integer i2 = new integer(66);
    Integer i3 = 66; // Integer = int，会自动装箱
    Integer i4 = 66;
    Integer i5 = 150;
    Integer i6 = 150;
    System.out.println(i1 == i2);//false
    System.out.println(i3 == i4);//true, 常量池[-128, 127]区间范围，取得是常量池，地址同一个
    System.out.println(i5 == i6);//false， 超出常量池范围，创建新对象
}


/*
*　Integer源码
*/
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

## 2. String

### 2.1 String常量池

- String由final修饰，不可被继承。
- String创建对象的两种方式

```java
//1、
String str = new String("abcd"); 
// 使用 new 创建的对象，存放在堆中。每次调用都会创建一个新的对象。
 
//2、
String str = "abcd";
// 先在栈上创建一个 String 类的对象引用变量 str，然后通过符号引用去字符串常量池中找有没有 “abcd”，如果没有，则将“abcd”存放到字符串常量池中，并将栈上的 str 变量引用指向常量池中的“abcd”。如果常量池中已经有“abcd”了，则不会再常量池中创建“abcd”，而是直接将 str 引用指向常量池中的“abcd”。
```

### 2.2 关于字符串 + 号连接问题 

对于字符串常量的 + 号连接，在程序编译期，JVM就会**将其优化为 + 号连接后的值**。所以在**编译期其字符串常量的值就确定了**。 

```java
    String a = "a1";   
    String b = "a" + 1;   // 编译后=》String b = “a1”
    System.out.println((a == b)); //result = true  
     
    String a = "a3.4";   
    String b = "a" + 3.4;  // 编译后=》String b = “a3.4” 
    System.out.println((a == b)); //result = true 

	String a = "a";
	String b = "ab";
	String c = a + "b"; // 反编译后发现， String c = (new StringBuilder()).append(a).append("b").toString(); 说明c对象是new出来的，而不是去常量池创建
	System.out.println((b == c)); //result = false 
	// c在编译期间无法确认a对象的值(是否会变化)，因此编译期间无法确认c的值。
	// 会在运行期间，动态的分配并将连接后的新地址复制给c。
```

因此，尽量不要在for中使用“+”符号操作字符串，而是使用StringBuffer/StringBuilder去替换。

上面demo中，`String c = a + "b"` , c在编译期间无法得知a的值，a可以用**final修饰**（这样a就是一个常量，编译期间就能获得它的值，就像d一样）。

### 2.3 intern()

调用 intern 方法，返回的是变量的内容，在常量池中的地址值

```java
public static void main(String[] args){
    String s = "ab";
    String s1 = "a";
    String s2 = "b";
    String s3 = s1 + s2;
    System.out.println(s3 == s);//false
    System.out.println(s3.intern() == s);//true
}
```





