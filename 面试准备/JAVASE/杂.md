# 杂

## 1. 包装类

### 1.1 比较大小时的自动拆箱

```java
public static void main(String[] args){
    Integer i1 = new Integer(4);
    Integer i2 = new Integer(6);
    Integer i3 = new Integer(10);
    Integer i4 = new Integer(10);
    System.out.print(i3 == i4);//false, 比较的是地址
    System.out.print(i3 == i1+i2);//true
    // 解析
    // 对象无法进行“+”操作，所以包装类i1和i2会先拆箱成int，然后进行“+”操作，则右边结果为(int)10，而包装类和基本数据类型比较也会先拆箱，所以左边为（int）10，所以比较的是大小，而非地址值。
}
```

### 1.2 Integer的常量池[-128, 127]

```java
public static void main(String[] args)
{

    Integer i1 = new Integer(66);
    Integer i2 = new integer(66);
    Integer i3 = 66; // Integer = int，会自动装箱
    Integer i4 = 66;
    Integer i5 = 150;
    Integer i6 = 150;
    System.out.println(i1 == i2);//false
    System.out.println(i3 == i4);//true, 常量池[-128, 127]区间范围，取得是常量池，地址同一个
    System.out.println(i5 == i6);//false， 超出常量池范围，创建新对象
}


/*
*　Integer源码
*/
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

### 1.3 包装类也是final修饰的

意味着和String类似，每次赋值都会产生新的对象，地址指向就变了，不再是原来的值。**所以包装类方法传参并不会改变原来的值。** 

```java
private static void test02() {
    Integer i = 200;
    System.out.println(i.getClass().getName() + "@" + Integer.toHexString(i.hashCode())); 
    // java.lang.Integer@c8
    i += 2;
    System.out.println(i.getClass().getName() + "@" + Integer.toHexString(i.hashCode())); 
    // java.lang.Integer@ca

}
```

```java
private static void test02(integer i) {
    i+=1;
}
main () {
    Integer a = 2;
    test02(a);
    sout(a); // 仍然是2
}
```



## 2. String

### 2.1 String常量池

- String由final修饰，不可被继承。
- String创建对象的两种方式

```java
//1、
String str = new String("abcd"); 
// 使用 new 创建的对象，存放在堆中。每次调用都会创建一个新的对象。
 
//2、
String str = "abcd";
// 先在栈上创建一个 String 类的对象引用变量 str，然后通过符号引用去字符串常量池中找有没有 “abcd”，如果没有，则将“abcd”存放到字符串常量池中，并将栈上的 str 变量引用指向常量池中的“abcd”。如果常量池中已经有“abcd”了，则不会再常量池中创建“abcd”，而是直接将 str 引用指向常量池中的“abcd”。
```

### 2.2 关于字符串 + 号连接问题(实质是StringBuilder.append) 

对于字符串常量的 + 号连接，在程序编译期，JVM就会**将其优化为 + 号连接后的值**。所以在**编译期其字符串常量的值就确定了**。 

```java
    String a = "a1";   
    String b = "a" + 1;   // 编译后=》String b = “a1”
    System.out.println((a == b)); //result = true  
     
    String a = "a3.4";   
    String b = "a" + 3.4;  // 编译后=》String b = “a3.4” 
    System.out.println((a == b)); //result = true 

	String a = "a";
	String b = "ab";
	String c = a + "b"; // 反编译后发现， String c = (new StringBuilder()).append(a).append("b").toString(); 说明c对象是new出来的，而不是去常量池创建
	System.out.println((b == c)); //result = false 
	// c在编译期间无法确认a对象的值(是否会变化)，因此编译期间无法确认c的值。
	// 会在运行期间，动态的分配并将连接后的新地址复制给c。
```

因此，尽量不要在for中使用“+”符号操作字符串，而是**使用StringBuffer/StringBuilder去替换**。

上面demo中，`String c = a + "b"` , c在编译期间无法得知a的值，a可以用**final修饰**（这样a就是一个常量，编译期间就能获得它的值，就像d一样）。

### 2.3 intern()

调用 intern 方法。

从JDK7开始，**如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在<u>堆上的地址引用复制到常量池</u>。**(intern不再拷贝字符串到常量池，而是只有堆的地址引用ef0010, 相比之前，可以节省空间) 

![1615098869302](E:\SoftwareNote\面试准备\JAVASE\img\String的intern方法.png)

```java
public static void main(String[] args){
    String str0 = "57tongcheng";
    String str1 = new String("58tongcheng2");
    String str2 = new StringBuilder("58").append("tongcheng").toString();
    String str3 = new StringBuilder("ja").append("va").toString();
    String str4 = new StringBuilder("57").append("tongcheng").toString();
    System.out.println(str0 == str0.intern()); // true, str0 = "57tongcheng"是创建在字符串常量池，str0.intern指向的是"57tongcheng"首次引用的地址，而就是str0的地址，即常量池地址
    System.out.println(str1 == str1.intern()); // false， new String是创建对象(并且同时在常量池加入该字符串)，intern返回的是字符串常量池中的地址，new的是另外一个地址。（new创建2个地址：new+常量池）
    System.out.println(str2 == str2.intern()); // true， "58tongcheng"再常量池没有，所以intern指向str2的对象地址
    System.out.println(str3 == str3.intern()); // false, "java"字符串在常量池已有()，intern指向第一次的对象引用地址
    System.out.println(str4 == str4.intern()); // false，"57tongcheng"str0已经加入到常量池，所以str4.intern指向的是str0的地址，也就是常量池地址
}
```

- "java"常量池的由来

```java
public final class System {

    /* register the natives via the static initializer.
     *
     * VM will invoke the initializeSystemClass method to complete
     * the initialization for this class separated from clinit.
     * Note that to use properties set by the VM, see the constraints
     * described in the initializeSystemClass method.
     */
    private static native void registerNatives();
    static {
        registerNatives();
    }
    
    
    private static void initializeSystemClass() {

        // VM might invoke JNU_NewStringPlatform() to set those encoding
        // sensitive properties (user.home, user.name, boot.class.path, etc.)
        // during "props" initialization, in which it may need access, via
        // System.getProperty(), to the related system encoding property that
        // have been initialized (put into "props") at early stage of the
        // initialization. So make sure the "props" is available at the
        // very beginning of the initialization and all system properties to
        // be put into it directly.
        props = new Properties();
        initProperties(props);  // initialized by the VM

        // There are certain system configurations that may be controlled by
        // VM options such as the maximum amount of direct memory and
        // Integer cache size used to support the object identity semantics
        // of autoboxing.  Typically, the library will obtain these values
        // from the properties set by the VM.  If the properties are for
        // internal implementation use only, these properties should be
        // removed from the system properties.
        //
        // See java.lang.Integer.IntegerCache and the
        // sun.misc.VM.saveAndRemoveProperties method for example.
        //
        // Save a private copy of the system properties object that
        // can only be accessed by the internal implementation.  Remove
        // certain system properties that are not intended for public access.
        sun.misc.VM.saveAndRemoveProperties(props);


        lineSeparator = props.getProperty("line.separator");
        sun.misc.Version.init(); // 这里
    }
}
    
public class Version {
    private static final String launcher_name = "java"; // 这里，“java”.intern指向的是launcher_name
    private static final String java_version = "1.8.0_112";
    private static final String java_runtime_name = "Java(TM) SE Runtime Environment";
    private static final String java_profile_name = "";
    private static final String java_runtime_version = "1.8.0_112-b15";
    private static boolean versionsInitialized;
}
    
    
    
    
```

## 3. Class方法

### 3.1 getModifiers

- `public native int getModifiers()`,通过返回值可以确定该对象（方法/字段）的全部访问修饰符

  得到的就是 前面的 的修饰符 ，这个方法 字段和方法 都有。这个方法的值是 修饰符 相加的到的值 

  ```java
  public class Test1 {
  
      String c;
      public String a;
      private String b;
      protected String d;
      static String e;
      final String f="f";
  	
      public static void main(String[] args) {
          Field[] fields = Test1.class.getDeclaredFields();
          for( Field field: fields) {
              System.out.println( field.getName() +":" + field.getModifiers() );
              // c:0
              // a:1
              // b:2
              // d:4
              // e:8
              // f:16
          }
      }
  }
  ```

  所以：什么都不加 是0 ， public  是1 ，private 是 2 ，protected 是 4，static 是 8 ，final 是 16。

  如果是   public  static final  三个修饰的 就是3 个的加和 为 25 。

### 3.2 isAssignableFrom 

- 作用： 判断类是否有继承关系，类似instanceof

- 与instanceof的区别

  - instanceof 是判断实例是否是继承关系

    ```java
    if (businesDetail instanceof DiscoutBizDetail)
    ```

  - isAssignableFrom则是判断类是否是继承关系

    ```java
    DiscoutBizDetail.class.isAssignableFrom(businesDetail.getClass())
    ```

isAssignableFrom() 

## 4. ++/-- 操作数栈和常量池

**总结：算数运算是在操作数栈里面运算，而++动作直接改变常量的值，即自增自减不经过操作数栈**

```java
main() {
    int i = 1;    //   1.局部变量 i=‘’   ，2.操作数栈: 1    ,  3.赋值动作 i=1
    i = i++;      //   1.局部变量 i=1    ，2.操作数栈: 1(因为是后++)  , 3.i++动作直接修改局部变量,此时局部变量自增：局部变量i=2,操作数栈：1   4.赋值动作：i(2)=1; 2被1覆盖
    int j = i++;  // 1. 和第二行一样，只是i++后，没有再次赋值覆盖i，执行完后i=2；j=1
    int k = i + ++i * i++;  // 1. 局部：i=2;操作栈：2->(++i动作)
    					  // 2. ++i动作：局部：i=3；操作栈：2->3(++i会重新拿局部值)->(i++动作)
    					  // 3. i++动作：先操作栈：2->3->3；局部：i=4
    					  // 4. 操作栈计算：11；赋值k=11

    System.out.println(i); // 4
    System.out.println(j); // 1
    System.out.println(k); // 11
}
```

![1621933737430](E:\SoftwareNote\面试准备\JAVASE\img\++ 操作数栈和常量池.png)

## 5. 类的初始化/实例的初始化过程

 对象实例化过程(同级则顺序执行)

1. 父类静态对象(首次加载)\<clinit>

2. 子类静态对象(首次加载)\<clinit>

3. 父类非静态对象(注意是否有子类重写，重写则直接调用子类)（3优先于4执行，是因为构造方法会隐式调用super()）\<init>

    3.5 父类构造方法

4. 子类非静态对象\<init>

​        4.5子类构造方法

- 类的初始化
  - 子类初始化需要先初始化父类
  - 一个类的初始化就是执行\<clinit>方法
    - 其中\<clinit>方法由静态变量+静态代码块组成
    - 执行顺序从上往下
  - \<clinit>只执行一次
- 实例初始化
  - 初始化就是调用\<init>方法
  - \<init>方法可能重载有多个，有几个重载方法就有几个\<init>
  - \<init>方法由非静态变量+非静态代码块+构造方法组成
  - 执行顺序从上往下，但是构造方法最后执行。
  - \<init>方法的首行是super([arg])(总是有，不写就是默认有)，即父类的\<init>方法

```java
// 对象实例化过程(同级则顺序执行)
// 1. 父类静态对象(首次加载)<clinit>
// 2. 子类静态对象(首次加载)<clinit>
// 3. 父类非静态对象(注意是否有子类重写，重写则直接调用子类)（3优先于4执行，是因为构造方法会隐式调用super()）<init>
// 3.5 父类构造方法
// 4. 子类非静态对象<init>
// 4.5. 子类构造方法
public class ClassInstanceOrder {
    public static void main(String[] args) {
        Son son1 = new Son(); // 1234567589
        System.out.println();
        Son son2 = new Son(); // 567589
    }
}

class Farther {
    private int i = test();
    private static int j = method();


    public Farther () {
        System.out.print(7);
    }

    static {
        System.out.print(2);
    }

    {
        System.out.print(6);
    }

    public int test() {
        System.out.print("---执行不到---");
        return 0;
    }

    public static int method() {
        System.out.print(1);
        return 0;
    }

}

class Son extends Farther {
    private int i = test();
    private static int j = method();



    public Son () {
        System.out.print(9);
    }

    static {
        System.out.print(4);
    }

    {
        System.out.print(8);
    }

    public int test() {
        System.out.print(5);
        return 0;
    }

    public static int method() {
        System.out.print(3);
        return 0;
    }
}
```

## 6. 方法的重写和重载

### 6.1 方法重写

- 不可重写
  - 父类final修饰
  - 父类static修饰
  - 父类private修饰
- 性质：
  - 相同方法名
  - 访问修饰符不严于父类
  - 不抛出比父类范围大的异常
  - 返回值是父类的或extends

### 6.2 方法重载

- 性质：
  - 相同方法名
  - 形参个数或顺序不同
  - 与修饰符/返回值无关

## 7. 局部变量和成员变量

- 局部变量存在的位置
  - 方法块内部
  - **代码块内部**

  ```java
  int i = 0;
  {
      int i = 9;
      i++;
      this.i++;
  }
  ```

- 成员变量：

  - 静态变量
  - 非静态变量

- 值得存储位置：

  - 局部变量：**栈**
  - 非静态成员变量：堆
  - 静态成员变量：**方法区**

## 8. 反射相关

### 8.1 ParameterizedType

所有的泛型 instanceof ParameterizedType.