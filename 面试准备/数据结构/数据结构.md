# 数据结构

![1619362580681](E:\SoftwareNote\面试准备\数据结构\img\数据结构.png)

## 1.一些知识点

### 1.1 增强for (T t : Collection) 底层也是iterator遍历

## 2. ArrayList

### 2.1 扩容机制

```java
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; // {} 默认空
}

public ArrayList(int initialCapacity) {
    if (initialCapacity > 0) {
        // 创建一个
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        // 空{}
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    }
}


public boolean add(E e) {
    // 扩容判断处理，当前长度+1
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    // 增加元素
    elementData[size++] = e;
    return true;
}

private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        // DEFAULT_CAPACITY = 10
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }

    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // overflow-conscious code
    // 所需的容量 > 原数组长度，则需要扩容
    if (minCapacity - elementData.length > 0)
        // 真正扩容逻辑
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    // 这里可以看出扩容是在原基础上扩1.5倍
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    // 当old=0时，new也为0，所以会进下面逻辑为new赋新值，而不是上面的1.5倍扩容
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    // Arrays.copyOf() 可以保留原来的数据
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

## 3. Vector

### 3.1 Vector和ArrayList比较

- 如果是无参构造器，默认都是10个长度

- Vector线程安全/效率低，ArrayList反之。
- 扩容倍数：vector为2倍，ArrayList为1.5

### 3.2 扩容机制

```java
public Vector() {
    // 无参构造，默认长度10
    this(10);
}

public Vector(int initialCapacity) {
    this(initialCapacity, 0);
}

// capacityIncrement构造方法可指定扩容大小。无指定则为2倍
public Vector(int initialCapacity, int capacityIncrement) {
    super();
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    this.elementData = new Object[initialCapacity];
    this.capacityIncrement = capacityIncrement;
}

public synchronized boolean add(E e) {
    modCount++;
    // 尝试扩容，当前长度+1
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}

private void ensureCapacityHelper(int minCapacity) {
    // overflow-conscious code
    // 判断是否需要扩容
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    // capacityIncrement构造方法传入的扩容数，没传则为0
    // 无capacityIncrement构造，扩容为oldCapacity+oldCapacity，2倍扩容
    // 有capacityIncrement构造，扩容为oldCapacity+capacityIncrement
    int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                     capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

## 4. LinkedList

### 4.1是双向链表

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

### 4.2 LinkedList和ArrayList对比

- 底层结构：ArrayList底层是可变数组，LinkedList底层是双向链表
- 效率: ArrayList查询/修改快，LinkedList增删快

### 4.3 add(E)

```java
public boolean add(E e) {
    linkLast(e);
    return true;
}

void linkLast(E e) {
    final Node<E> l = last;
    // e.pre = l
    final Node<E> newNode = new Node<>(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        // l.next = e   , 加上上面的就是双向指向了
        l.next = newNode;
    size++;
    modCount++;
}
```

### 4.4 add(index, E)

```java
public void add(int index, E element) {
    checkPositionIndex(index);

    if (index == size)
        linkLast(element);
    else
        linkBefore(element, node(index));
}

Node<E> node(int index) {
    // assert isElementIndex(index);

    if (index < (size >> 1)) {
        Node<E> x = first;
        for (int i = 0; i < index; i++)
            x = x.next;
        return x;
    } else {
        Node<E> x = last;
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x;
    }
}

void linkBefore(E e, Node<E> succ) {
    // assert succ != null;
    final Node<E> pred = succ.prev;
    final Node<E> newNode = new Node<>(pred, e, succ);
    succ.prev = newNode;
    if (pred == null)
        first = newNode;
    else
        pred.next = newNode;
    size++;
    modCount++;
}
```

### 4.5 remove(index)

```java
public E remove(int index) {
    checkElementIndex(index);
    return unlink(node(index));
}
E unlink(Node<E> x) {
    // assert x != null;
    final E element = x.item;
    final Node<E> next = x.next;
    final Node<E> prev = x.prev;

    if (prev == null) {
        first = next;
    } else {
        prev.next = next;
        x.prev = null;
    }

    if (next == null) {
        last = prev;
    } else {
        next.prev = prev;
        x.next = null;
    }

    x.item = null;
    size--;
    modCount++;
    return element;
}
```

## 5. HashSet

- 底层是HashMap

```java
public HashSet() {
    map = new HashMap<>();
}
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
```

## 6. HashMap

### 6.1 底层

- 底层是数组+链表+红黑树(jdk8)

- 添加流程：
  - 先得到Key的hash值（转换为索引值）
  - 在存储数据表table中，查看该索引位置是否有存值
  - 没有则直接加入
  - 有则调用equals方法依次与该索引中的其他元素比较，相同则放弃添加，不同则添加到最后
  - 在JAVA8中，如果一条链表的元素个数(TREEIFY_THRESHOLD)到达8个(默认)，并且数据表table中的大小>=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树)

- 扩容resize

  - 扩容：计算出新长度size和新临界值threshold

  - 扩容规则：

    1.0 首次扩容
    	newCap = DEFAULT_INITIAL_CAPACITY(1 << 4）= 16
            newThr = (int)(DEFAULT_LOAD_FACTOR(0.75f) * DEFAULT_INITIAL_CAPACITY(1 << 4）); = 12
    1.1. oldSize > MAXIMUM_CAPACITY(1<<30) ,临界值threshold = Integer.MAX_VALUE，不再扩容
    1.2. newCap和newThr各扩容一倍（size<1）

  - 从老数据拷贝到新数据中Node[]

  - 
     put方法一共有三处地方扩容：
          // 1.put的时候发现超过临界值
          // 2. 首次put
          // 3. 调用树化方法时，发现table.length还未达到MIN_TREEIFY_CAPACITY(64)

- 树化（红黑树）treeifyBin，满足以下条件

  A. 如果链表的长度>=TREEIFY_THRESHOLD - 1=7,即链表达到8长度，那么则进入树化方法，但是还需判断B
  B. 方法内部隐藏条件，table长度>=64。如果<64，那么不会树化，而是执行resize扩容

### 6.2 源码解读

- HashSet底层是HashMap

```java
public HashSet() {
    map = new HashMap<>();
}

// Map.Entry遍历时，实际上遍历的是Node
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;
}
```

- ConcurrentModificationException异常

```java
 public void forEach(BiConsumer<? super K, ? super V> action) {
     Node<K,V>[] tab;
     if (action == null)
         throw new NullPointerException();
     if (size > 0 && (tab = table) != null) {
         int mc = modCount;
         for (int i = 0; i < tab.length; ++i) {
             for (Node<K,V> e = tab[i]; e != null; e = e.next)
                 action.accept(e.key, e.value);
         }
         // 遍历中发现长度变化，抛出ConcurrentModificationException异常
         if (modCount != mc)
             throw new ConcurrentModificationException();
     }
 }
```

- add 调用的是HashMap的put，而value为final空对象

```java
private static final Object PRESENT = new Object();
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
```

- hashMap.put

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

// 可以看出，HashMap.hash并不是Object.hash，而是特殊处理过的
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        // table=null说明是首次创建add，要先执行resize()方法初始化table
        n = (tab = resize()).length;
    // (n - 1) & hash即 hash % n, 该key的hash模table长度，为存放位置
    if ((p = tab[i = (n - 1) & hash]) == null)
        // 该位置如果没人，则直接占着
        tab[i] = newNode(hash, key, value, null);
    else {
        // 该位置有人，则需要分情况考虑
        Node<K,V> e; K k;
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            // 如果hash相同并且（==或则equals相同），那么无需插入
            // 看到判断条件，可以得知如果某对象想改造成HashMap.put唯一，则需要重写hash和equals方法
            // 所以String对象，不同对象，字符串相同也算同一个对象，因为String重写了hash和equals
            e = p;
        else if (p instanceof TreeNode)
            // 如果该位置为TreeNode（Node的子类），说明该链表已经树化过了，直接调用TreeNode的
            // putTreeVal方法进行赋值
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            // 如果有人，并且上述2个条件都不符合，则插入到链路的最后
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        // 如果链表的长度>=TREEIFY_THRESHOLD - 1=7,即链表达到8长度，那么则进入树化
                        // 方法内部隐藏条件，table长度>=64
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    // 如果链路中的某对象和条件1一样，说明是同一个对象。那么也直接返回，无需插入
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                // 这边做的就是相同key，替换value
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    k-v长度，即table.length中不为null的长度
    if (++size > threshold)
        // 当size超过临界值，则进行扩容，所以扩容是在临界值提前扩容，而不是用完才扩容
        // put方法一共有三处地方扩容：
        // 1.put的时候发现超过临界值
        // 2. 首次put
        // 3. 调用树化方法时，发现table.length还未达到MIN_TREEIFY_CAPACITY(64)
        resize();
    // 这是个空实现，可以流程子类做特殊处理，如LinkedHashMap
    afterNodeInsertion(evict);
    return null;
}


/**
1. 扩容：计算出新长度size和新临界值threshold
	扩容规则：
	1.0 首次扩容
		newCap = DEFAULT_INITIAL_CAPACITY(1 << 4）= 16
        newThr = (int)(DEFAULT_LOAD_FACTOR(0.75f) * DEFAULT_INITIAL_CAPACITY(1 << 4）); = 12
	1.1. oldSize > MAXIMUM_CAPACITY(1<<30) ,临界值threshold = Integer.MAX_VALUE，不再扩容
	1.2. newCap和newThr各扩容一倍（size<1）
2. 从老数据拷贝到新数据中Node[]
3. 
		// put方法一共有三处地方扩容：
        // 1.put的时候发现超过临界值
        // 2. 首次put
        // 3. 调用树化方法时，发现table.length还未达到MIN_TREEIFY_CAPACITY(64)
*/
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap > 0) {
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                 oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
    }
    else if (oldThr > 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else {               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    // 拷贝老数据到新数据 oldTab -> newTab(即table)
    if (oldTab != null) {
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash & (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                else { // preserve order
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    do {
                        next = e.next;
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}

/**
树化链表 Node -> TreeNode
剪枝？  树->链表
*/
final void treeifyBin(Node<K,V>[] tab, int hash) {
    int n, index; Node<K,V> e;
    
    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
        resize();
    else if ((e = tab[index = (n - 1) & hash]) != null) {
        //  n = tab.length) < MIN_TREEIFY_CAPACITY=64 隐藏条件，table长度>=64
        TreeNode<K,V> hd = null, tl = null;
        do {
            TreeNode<K,V> p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}

```

- remove操作: 可以看到remove动作需要调用hash去找到对应的元素。那如果hashCode被重写，然后remove前元素被修改，那就删不到这个元素，因为元素属性变化后新旧hash已经不同。

```java
public V remove(Object key) {
    Node<K,V> e;
    return (e = removeNode(hash(key), key, null, false, true)) == null ?
        null : e.value;
}
```

下面这题，最终size为4

![1620725666009](E:\SoftwareNote\面试准备\数据结构\img\HashMap的remove题目.png)

## 7. LinkedHashSet

- 底层是LinkedHashMap

```java
public LinkedHashSet() {
    super(16, .75f, true);
}

HashSet(int initialCapacity, float loadFactor, boolean dummy) {
    map = new LinkedHashMap<>(initialCapacity, loadFactor);
}
```

## 8. LinkedHashMap

### 8.1 底层

- 数组+**双向链表**+红黑树(jdk8)

- 根据hashcode决定存储位置，链表存储决定了数据的有序性


![1620693701429](E:\SoftwareNote\面试准备\数据结构\img\LinkedHashMap底层机制.png)

### 8.2 源码解读

- 双向链表

```java
// 继承了Node，因此可以复用HashMap的putval方法
static class Entry<K,V> extends HashMap.Node<K,V> {
    // 双向链表的体现：多出before和after指针
    Entry<K,V> before, after;
    Entry(int hash, K key, V value, Node<K,V> next) {
        super(hash, key, value, next);
    }
}
```

- put操作: 实际底层就是调用HashMap.putval方法，差别就是LinkedHashMap重写了afterNodeAccess(e)和afterNodeInsertion(evict)方法，主要是做before/after/head/tail的处理

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e; K k;
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            // LinkedHashMap重写了该方法
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size > threshold)
        resize();
    // LinkedHashMap重写了该方法
    afterNodeInsertion(evict);
    return null;
}

// before和after赋值的秘密
// LinkedHashMap重写了HashMap的newNode方法
Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {
    LinkedHashMap.Entry<K,V> p =
        new LinkedHashMap.Entry<K,V>(hash, key, value, e);
    // 在这里做了赋值动作，将新元素加入到链表的最后，如果accessOrder为true后续才会排序
    linkNodeLast(p);
    return p;
}

private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {
    LinkedHashMap.Entry<K,V> last = tail;
    tail = p;
    if (last == null)
        head = p;
    else {
        p.before = last;
        last.after = p;
    }
}


// 添加过后的排序，将新增元素添加到最后
 void afterNodeAccess(Node<K,V> e) { // move node to last
     LinkedHashMap.Entry<K,V> last;
     // accessOrder构造函数传参，为true才排序
     if (accessOrder && (last = tail) != e) {
         LinkedHashMap.Entry<K,V> p =
             (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
         p.after = null;
         if (b == null)
             // b==null说明，p为原来的head，先交付给p.next，即p断掉
             head = a;
         else
             // b!= null 说明p非head，p.before.next=p.next,即p断掉
             b.after = a;
         if (a != null)
             a.before = b;
         else
             last = b;
         if (last == null)
             head = p;
         else {
             p.before = last;
             last.after = p;
         }
         tail = p;
         ++modCount;
     }
 }

// lua算法，移除最老元素，当removeEldestEntry(first)为true的时候(不重写默认false)，因此想要实现lua，只需重写该方法即可
void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry<K,V> first;
    if (evict && (first = head) != null && removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}

 final Node<K,V> removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
     Node<K,V>[] tab; Node<K,V> p; int n, index;
     if ((tab = table) != null && (n = tab.length) > 0 &&
         (p = tab[index = (n - 1) & hash]) != null) {
         Node<K,V> node = null, e; K k; V v;
         if (p.hash == hash &&
             ((k = p.key) == key || (key != null && key.equals(k))))
             node = p;
         else if ((e = p.next) != null) {
             if (p instanceof TreeNode)
                 node = ((TreeNode<K,V>)p).getTreeNode(hash, key);
             else {
                 do {
                     if (e.hash == hash &&
                         ((k = e.key) == key ||
                          (key != null && key.equals(k)))) {
                         node = e;
                         break;
                     }
                     p = e;
                 } while ((e = e.next) != null);
             }
         }
         if (node != null && (!matchValue || (v = node.value) == value ||
                              (value != null && value.equals(v)))) {
             if (node instanceof TreeNode)
                 ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
             else if (node == p)
                 tab[index] = node.next;
             else
                 p.next = node.next;
             ++modCount;
             --size;
             afterNodeRemoval(node);
             return node;
         }
     }
     return null;
 }
```

- get

```java
public V get(Object key) {
    Node<K,V> e;
    if ((e = getNode(hash(key), key)) == null)
        return null;
    if (accessOrder)
        afterNodeAccess(e);
    return e.value;
}


final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (first = tab[(n - 1) & hash]) != null) {
        // 通过hash先查找到链表，也算提高效率，如果是只有链表，那么就需要整个链表遍历
        // 这里的first指的是，table中链表的第一个元素
        if (first.hash == hash && // always check first node
            ((k = first.key) == key || (key != null && key.equals(k))))
            return first;
        if ((e = first.next) != null) {
            if (first instanceof TreeNode)
                // 树化了的，则调用树查询方法
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            do {
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
                // 否则遍历链表查找
            } while ((e = e.next) != null);
        }
    }
    return null;
}
```

## 9. Hashtable

### 9.1 和HashMap比较

|           | 版本 |          线程安全           | 效率 | 底层数据结构             |                    null值                    |
| :-------: | :--: | :-------------------------: | :--: | ------------------------ | :------------------------------------------: |
|  HashMap  | 1.2  |           不安全            |  高  | 数组+链表+红黑树（jdk8） |                     允许                     |
| Hashtable | 1.0  | 安全(推荐ConcurrentHashMap) | 较低 | 数组+链表                | 不允许null的key和value(NullPointerException) |

### 9.2 源码解读

- 默认大小 11,扩容因子0.75

```java
public Hashtable() {
    this(11, 0.75f);
}

public Hashtable(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal Load: "+loadFactor);

    if (initialCapacity==0)
        initialCapacity = 1;
    this.loadFactor = loadFactor;
    table = new Entry<?,?>[initialCapacity];
    threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
}
```

- put操作

```java
// synchronized保证线程安全，但锁的太多逻辑了，导致性能下降比较多
public synchronized V put(K key, V value) {
    // Make sure the value is not null
    if (value == null) {
        // value不准为空，否则抛出异常
        throw new NullPointerException();
    }

    // Makes sure the key is not already in the hashtable.
    Entry<?,?> tab[] = table;
    // hash直接等于hashCode()
    int hash = key.hashCode();
    // Integer.MAX_VALUE=0x7FFFFFFF
    // 为什么不用(hash & 0x7FFFFFFF) & (tab.length - 1)?
    // 因为table.lenth长度不为2的幂次方，因此无法套用公式
    int index = (hash & 0x7FFFFFFF) % tab.length;
    @SuppressWarnings("unchecked")
    Entry<K,V> entry = (Entry<K,V>)tab[index];
    // 只有entry.next，因为Hashtbale没有树，只有链表
    for(; entry != null ; entry = entry.next) {
        // 判断相同，比较的是Entry的hash而不是key的hash
        if ((entry.hash == hash) && entry.key.equals(key)) {
            // 条件符合，替换value，自己直接return
            V old = entry.value;
            entry.value = value;
            return old;
        }
    }
	// 真正的添加逻辑
    addEntry(hash, key, value, index);
    return null;
}

 private void addEntry(int hash, K key, V value, int index) {
     modCount++;

     Entry<?,?> tab[] = table;
     // 达到临界值，执行扩容
     if (count >= threshold) {
         // Rehash the table if the threshold is exceeded
         rehash();

         tab = table;
         hash = key.hashCode();
         index = (hash & 0x7FFFFFFF) % tab.length;
     }

     // Creates the new entry.
     @SuppressWarnings("unchecked")
     Entry<K,V> e = (Entry<K,V>) tab[index];
     tab[index] = new Entry<>(hash, key, value, e);
     count++;
 }

protected Entry(int hash, K key, V value, Entry<K,V> next) {
    this.hash = hash;
    this.key =  key;
    this.value = value;
    // 加到头部
    this.next = next;
}
```

- 扩容： old * 2 + 1   （临界值为newCapacity * loadFactor）

```java
protected void rehash() {
    int oldCapacity = table.length;
    Entry<?,?>[] oldMap = table;

    // overflow-conscious code
    // 扩容： old * 2 + 1
    int newCapacity = (oldCapacity << 1) + 1;
    if (newCapacity - MAX_ARRAY_SIZE > 0) {
        if (oldCapacity == MAX_ARRAY_SIZE)
            // Keep running with MAX_ARRAY_SIZE buckets
            return;
        newCapacity = MAX_ARRAY_SIZE;
    }
    Entry<?,?>[] newMap = new Entry<?,?>[newCapacity];

    modCount++;
    threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
    table = newMap;
	// 拷贝数据
    for (int i = oldCapacity ; i-- > 0 ;) {
        for (Entry<K,V> old = (Entry<K,V>)oldMap[i] ; old != null ; ) {
            Entry<K,V> e = old;
            old = old.next;

            int index = (e.hash & 0x7FFFFFFF) % newCapacity;
            e.next = (Entry<K,V>)newMap[index];
            newMap[index] = e;
        }
    }
}
```

## 10. Properties

- 继承Hashtable
- 用IO读取properties文件

## 11. TreeSet : 有序set

- 底层是TreeMap

```java
public TreeSet() {
    this(new TreeMap<E,Object>());
}

public TreeMap() {
    comparator = null;
}

public TreeMap(Comparator<? super K> comparator) {
    this.comparator = comparator;
}

static final class Entry<K,V> implements Map.Entry<K,V> {
    K key;
    V value;
    Entry<K,V> left;
    Entry<K,V> right;
    Entry<K,V> parent;
    boolean color = BLACK;
}
```

## 12. TreeMap：有序Map	

### 12.2 源码解读

- put操作

```java
public V put(K key, V value) {
    Entry<K,V> t = root;
    // t==null说明是首次添加
    if (t == null) {
        compare(key, key); // type (and possibly null) check

        root = new Entry<>(key, value, null);
        size = 1;
        modCount++;
        return null;
    }
    int cmp;
    Entry<K,V> parent;
    // split comparator and comparable paths
    Comparator<? super K> cpr = comparator;
    if (cpr != null) {
        // 循环遍历
        do {
            parent = t;
            // 比较，t实际上是指针，根据cmp的正负，选择往左往右移动
            cmp = cpr.compare(key, t.key);
            if (cmp < 0)
                t = t.left;
            else if (cmp > 0)
                t = t.right;
            else
                // 相同则修改value
                return t.setValue(value);
        } while (t != null);
    }
    else {
        if (key == null)
            throw new NullPointerException();
        @SuppressWarnings("unchecked")
        // 构造方法没有传入比较器的话，则使用泛型对象来比较，因此如果泛型对象没有实现Comparable，就会转换异常。ClassCastException。否则和上面逻辑一样。
        Comparable<? super K> k = (Comparable<? super K>) key;
        do {
            parent = t;
            cmp = k.compareTo(t.key);
            if (cmp < 0)
                t = t.left;
            else if (cmp > 0)
                t = t.right;
            else
                return t.setValue(value);
        } while (t != null);
    }
    Entry<K,V> e = new Entry<>(key, value, parent);
    // 跳出上面while循环，parent为e所接近的对象，根据cmp的大小，选择放在左还是右
    if (cmp < 0)
        parent.left = e;
    else
        parent.right = e;
    fixAfterInsertion(e);
    size++;
    modCount++;
    return null;
}

final int compare(Object k1, Object k2) {
    return comparator==null ? ((Comparable<? super K>)k1).compareTo((K)k2)
        : comparator.compare((K)k1, (K)k2);
}

// 红黑树修正
private void fixAfterInsertion(Entry<K,V> x) {
    x.color = RED;

    while (x != null && x != root && x.parent.color == RED) {
        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
            Entry<K,V> y = rightOf(parentOf(parentOf(x)));
            if (colorOf(y) == RED) {
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else {
                if (x == rightOf(parentOf(x))) {
                    x = parentOf(x);
                    rotateLeft(x);
                }
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                rotateRight(parentOf(parentOf(x)));
            }
        } else {
            Entry<K,V> y = leftOf(parentOf(parentOf(x)));
            if (colorOf(y) == RED) {
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else {
                if (x == leftOf(parentOf(x))) {
                    x = parentOf(x);
                    rotateRight(x);
                }
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                rotateLeft(parentOf(parentOf(x)));
            }
        }
    }
    root.color = BLACK;
}
```

- ClassCastException:  泛型对象没有实现Comparable并且构造方法没有传入比较器

```java
 else {
     if (key == null)
         throw new NullPointerException();
     @SuppressWarnings("unchecked")
     // 构造方法没有传入比较器的话，则使用泛型对象来比较，因此如果泛型对象没有实现Comparable，就会转换异常。ClassCastException。否则和上面逻辑一样。
     Comparable<? super K> k = (Comparable<? super K>) key;
     do {
         parent = t;
         cmp = k.compareTo(t.key);
         if (cmp < 0)
             t = t.left;
         else if (cmp > 0)
             t = t.right;
         else
             return t.setValue(value);
     } while (t != null);
 }
```

