# 数据结构

![1619362580681](E:\SoftwareNote\面试准备\数据结构\img\数据结构.png)

## 1.一些知识点

### 1.1 增强for (T t : Collection) 底层也是iterator遍历

## 2. ArrayList

### 2.1 扩容机制

```java
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; // {} 默认空
}

public ArrayList(int initialCapacity) {
    if (initialCapacity > 0) {
        // 创建一个
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        // 空{}
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    }
}


public boolean add(E e) {
    // 扩容判断处理，当前长度+1
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    // 增加元素
    elementData[size++] = e;
    return true;
}

private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        // DEFAULT_CAPACITY = 10
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }

    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // overflow-conscious code
    // 所需的容量 > 原数组长度，则需要扩容
    if (minCapacity - elementData.length > 0)
        // 真正扩容逻辑
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    // 这里可以看出扩容是在原基础上扩1.5倍
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    // 当old=0时，new也为0，所以会进下面逻辑为new赋新值，而不是上面的1.5倍扩容
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    // Arrays.copyOf() 可以保留原来的数据
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

## 3. Vector

### 3.1 Vector和ArrayList比较

- 如果是无参构造器，默认都是10个长度

- Vector线程安全/效率低，ArrayList反之。
- 扩容倍数：vector为2倍，ArrayList为1.5

### 3.2 扩容机制

```java
public Vector() {
    // 无参构造，默认长度10
    this(10);
}

public Vector(int initialCapacity) {
    this(initialCapacity, 0);
}

// capacityIncrement构造方法可指定扩容大小。无指定则为2倍
public Vector(int initialCapacity, int capacityIncrement) {
    super();
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    this.elementData = new Object[initialCapacity];
    this.capacityIncrement = capacityIncrement;
}

public synchronized boolean add(E e) {
    modCount++;
    // 尝试扩容，当前长度+1
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}

private void ensureCapacityHelper(int minCapacity) {
    // overflow-conscious code
    // 判断是否需要扩容
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    // capacityIncrement构造方法传入的扩容数，没传则为0
    // 无capacityIncrement构造，扩容为oldCapacity+oldCapacity，2倍扩容
    // 有capacityIncrement构造，扩容为oldCapacity+capacityIncrement
    int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                     capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

## 4. LinkedList

### 4.1是双向链表

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

### 4.2 LinkedList和ArrayList对比

- 底层结构：ArrayList底层是可变数组，LinkedList底层是双向链表
- 效率: ArrayList查询/修改快，LinkedList增删快

### 4.3 add(E)

```java
public boolean add(E e) {
    linkLast(e);
    return true;
}

void linkLast(E e) {
    final Node<E> l = last;
    // e.pre = l
    final Node<E> newNode = new Node<>(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        // l.next = e   , 加上上面的就是双向指向了
        l.next = newNode;
    size++;
    modCount++;
}
```

### 4.4 add(index, E)

```java
public void add(int index, E element) {
    checkPositionIndex(index);

    if (index == size)
        linkLast(element);
    else
        linkBefore(element, node(index));
}

Node<E> node(int index) {
    // assert isElementIndex(index);

    if (index < (size >> 1)) {
        Node<E> x = first;
        for (int i = 0; i < index; i++)
            x = x.next;
        return x;
    } else {
        Node<E> x = last;
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x;
    }
}

void linkBefore(E e, Node<E> succ) {
    // assert succ != null;
    final Node<E> pred = succ.prev;
    final Node<E> newNode = new Node<>(pred, e, succ);
    succ.prev = newNode;
    if (pred == null)
        first = newNode;
    else
        pred.next = newNode;
    size++;
    modCount++;
}
```

### 4.5 remove(index)

```java
public E remove(int index) {
    checkElementIndex(index);
    return unlink(node(index));
}
E unlink(Node<E> x) {
    // assert x != null;
    final E element = x.item;
    final Node<E> next = x.next;
    final Node<E> prev = x.prev;

    if (prev == null) {
        first = next;
    } else {
        prev.next = next;
        x.prev = null;
    }

    if (next == null) {
        last = prev;
    } else {
        next.prev = prev;
        x.next = null;
    }

    x.item = null;
    size--;
    modCount++;
    return element;
}
```

## 5. HashSet

- 底层是HashMap

```java
public HashSet() {
    map = new HashMap<>();
}
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
```

## 6. HashMap

### 6.1 底层

- 底层是数组+链表+红黑树(jdk8)

- 添加流程：
  - 先得到Key的hash值（转换为索引值）
  - 在存储数据表table中，查看该索引位置是否有存值
  - 没有则直接加入
  - 有则调用equals方法依次与该索引中的其他元素比较，相同则放弃添加，不同则添加到最后
  - 在JAVA8中，如果一条链表的元素个数(TREEIFY_THRESHOLD)到达8个(默认)，并且数据表table中的大小>=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树)

- 扩容resize

  - 扩容：计算出新长度size和新临界值threshold

  - 扩容规则：

    1.0 首次扩容
    	newCap = DEFAULT_INITIAL_CAPACITY(1 << 4）= 16
            newThr = (int)(DEFAULT_LOAD_FACTOR(0.75f) * DEFAULT_INITIAL_CAPACITY(1 << 4）); = 12
    1.1. oldSize > MAXIMUM_CAPACITY(1<<30) ,临界值threshold = Integer.MAX_VALUE，不再扩容
    1.2. newCap和newThr各扩容一倍（size<1）

  - 从老数据拷贝到新数据中Node[]

  - 
     put方法一共有三处地方扩容：
          // 1.put的时候发现超过临界值
          // 2. 首次put
          // 3. 调用树化方法时，发现table.length还未达到MIN_TREEIFY_CAPACITY(64)

- 树化（红黑树）treeifyBin，满足以下条件

  A. 如果链表的长度>=TREEIFY_THRESHOLD - 1=7,即链表达到8长度，那么则进入树化方法，但是还需判断B
  B. 方法内部隐藏条件，table长度>=64。如果<64，那么不会树化，而是执行resize扩容

### 6.2 源码解读

- HashSet底层是HashMap

```java
public HashSet() {
    map = new HashMap<>();
}

// Map.Entry遍历时，实际上遍历的是Node
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;
}
```

- ConcurrentModificationException异常

```java
 public void forEach(BiConsumer<? super K, ? super V> action) {
     Node<K,V>[] tab;
     if (action == null)
         throw new NullPointerException();
     if (size > 0 && (tab = table) != null) {
         int mc = modCount;
         for (int i = 0; i < tab.length; ++i) {
             for (Node<K,V> e = tab[i]; e != null; e = e.next)
                 action.accept(e.key, e.value);
         }
         // 遍历中发现长度变化，抛出ConcurrentModificationException异常
         if (modCount != mc)
             throw new ConcurrentModificationException();
     }
 }
```

- add 调用的是HashMap的put，而value为final空对象

```java
private static final Object PRESENT = new Object();
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
```

- hashMap.put

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

// 可以看出，HashMap.hash并不是Object.hash，而是特殊处理过的
// key.hashCode()是int类型，长度为32bit
//右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        // table=null说明是首次创建add，要先执行resize()方法初始化table
        n = (tab = resize()).length;
    // (n - 1) & hash即 hash % n, 该key的hash模table长度，为存放位置
    if ((p = tab[i = (n - 1) & hash]) == null)
        // 该位置如果没人，则直接占着
        tab[i] = newNode(hash, key, value, null);
    else {
        // 该位置有人，则需要分情况考虑
        Node<K,V> e; K k;
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            // 如果hash相同并且（==或则equals相同），那么无需插入
            // 看到判断条件，可以得知如果某对象想改造成HashMap.put唯一，则需要重写hash和equals方法
            // 所以String对象，不同对象，字符串相同也算同一个对象，因为String重写了hash和equals
            e = p;
        else if (p instanceof TreeNode)
            // 如果该位置为TreeNode（Node的子类），说明该链表已经树化过了，直接调用TreeNode的
            // putTreeVal方法进行赋值
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            // 如果有人，并且上述2个条件都不符合，则插入到链路的最后
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        // 如果链表的长度>=TREEIFY_THRESHOLD - 1=7,即链表达到8长度，那么则进入树化
                        // 方法内部隐藏条件，table长度>=64
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    // 如果链路中的某对象和条件1一样，说明是同一个对象。那么也直接返回，无需插入
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                // 这边做的就是相同key，替换value
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    k-v长度，即table.length中不为null的长度
    if (++size > threshold)
        // 当size超过临界值，则进行扩容，所以扩容是在临界值提前扩容，而不是用完才扩容
        // put方法一共有三处地方扩容：
        // 1.put的时候发现超过临界值
        // 2. 首次put
        // 3. 调用树化方法时，发现table.length还未达到MIN_TREEIFY_CAPACITY(64)
        resize();
    // 这是个空实现，可以流程子类做特殊处理，如LinkedHashMap
    afterNodeInsertion(evict);
    return null;
}


/**
1. 扩容：计算出新长度size和新临界值threshold
	扩容规则：
	1.0 首次扩容
		newCap = DEFAULT_INITIAL_CAPACITY(1 << 4）= 16
        newThr = (int)(DEFAULT_LOAD_FACTOR(0.75f) * DEFAULT_INITIAL_CAPACITY(1 << 4）); = 12
	1.1. oldSize > MAXIMUM_CAPACITY(1<<30) ,临界值threshold = Integer.MAX_VALUE，不再扩容
	1.2. newCap和newThr各扩容一倍（size<1）
2. 从老数据拷贝到新数据中Node[]
3. 
		// put方法一共有三处地方扩容：
        // 1.put的时候发现超过临界值
        // 2. 首次put
        // 3. 调用树化方法时，发现table.length还未达到MIN_TREEIFY_CAPACITY(64)
*/
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap > 0) {
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                 oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
    }
    else if (oldThr > 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else {               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    // 拷贝老数据到新数据 oldTab -> newTab(即table)
    if (oldTab != null) {
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash & (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                else { // preserve order
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    do {
                        next = e.next;
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}

/**
树化链表 Node -> TreeNode
剪枝？  树->链表
*/
final void treeifyBin(Node<K,V>[] tab, int hash) {
    int n, index; Node<K,V> e;
    
    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
        resize();
    else if ((e = tab[index = (n - 1) & hash]) != null) {
        //  n = tab.length) < MIN_TREEIFY_CAPACITY=64 隐藏条件，table长度>=64
        TreeNode<K,V> hd = null, tl = null;
        do {
            TreeNode<K,V> p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}

```

- remove操作: 可以看到remove动作需要调用hash去找到对应的元素。那如果hashCode被重写，然后remove前元素被修改，那就删不到这个元素，因为元素属性变化后新旧hash已经不同。

```java
public V remove(Object key) {
    Node<K,V> e;
    return (e = removeNode(hash(key), key, null, false, true)) == null ?
        null : e.value;
}
```

下面这题，最终size为4

![1620725666009](E:\SoftwareNote\面试准备\数据结构\img\HashMap的remove题目.png)

## 7. LinkedHashSet

- 底层是LinkedHashMap

```java
public LinkedHashSet() {
    super(16, .75f, true);
}

HashSet(int initialCapacity, float loadFactor, boolean dummy) {
    map = new LinkedHashMap<>(initialCapacity, loadFactor);
}
```

## 8. LinkedHashMap

### 8.1 底层

- 数组+**双向链表**+红黑树(jdk8)

- 根据hashcode决定存储位置，链表存储决定了数据的有序性


![1620693701429](E:\SoftwareNote\面试准备\数据结构\img\LinkedHashMap底层机制.png)

### 8.2 源码解读

- 双向链表

```java
// 继承了Node，因此可以复用HashMap的putval方法
static class Entry<K,V> extends HashMap.Node<K,V> {
    // 双向链表的体现：多出before和after指针
    Entry<K,V> before, after;
    Entry(int hash, K key, V value, Node<K,V> next) {
        super(hash, key, value, next);
    }
}
```

- put操作: 实际底层就是调用HashMap.putval方法，差别就是LinkedHashMap重写了afterNodeAccess(e)和afterNodeInsertion(evict)方法，主要是做before/after/head/tail的处理

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e; K k;
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            // LinkedHashMap重写了该方法
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size > threshold)
        resize();
    // LinkedHashMap重写了该方法
    afterNodeInsertion(evict);
    return null;
}

// before和after赋值的秘密
// LinkedHashMap重写了HashMap的newNode方法
Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {
    LinkedHashMap.Entry<K,V> p =
        new LinkedHashMap.Entry<K,V>(hash, key, value, e);
    // 在这里做了赋值动作，将新元素加入到链表的最后，如果accessOrder为true后续才会排序
    linkNodeLast(p);
    return p;
}

private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {
    LinkedHashMap.Entry<K,V> last = tail;
    tail = p;
    if (last == null)
        head = p;
    else {
        p.before = last;
        last.after = p;
    }
}


// 添加过后的排序，将新增元素添加到最后
 void afterNodeAccess(Node<K,V> e) { // move node to last
     LinkedHashMap.Entry<K,V> last;
     // accessOrder构造函数传参，为true才排序
     if (accessOrder && (last = tail) != e) {
         LinkedHashMap.Entry<K,V> p =
             (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
         p.after = null;
         if (b == null)
             // b==null说明，p为原来的head，先交付给p.next，即p断掉
             head = a;
         else
             // b!= null 说明p非head，p.before.next=p.next,即p断掉
             b.after = a;
         if (a != null)
             a.before = b;
         else
             last = b;
         if (last == null)
             head = p;
         else {
             p.before = last;
             last.after = p;
         }
         tail = p;
         ++modCount;
     }
 }

// lua算法，移除最老元素，当removeEldestEntry(first)为true的时候(不重写默认false)，因此想要实现lua，只需重写该方法即可
void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry<K,V> first;
    if (evict && (first = head) != null && removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}

 final Node<K,V> removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
     Node<K,V>[] tab; Node<K,V> p; int n, index;
     if ((tab = table) != null && (n = tab.length) > 0 &&
         (p = tab[index = (n - 1) & hash]) != null) {
         Node<K,V> node = null, e; K k; V v;
         if (p.hash == hash &&
             ((k = p.key) == key || (key != null && key.equals(k))))
             node = p;
         else if ((e = p.next) != null) {
             if (p instanceof TreeNode)
                 node = ((TreeNode<K,V>)p).getTreeNode(hash, key);
             else {
                 do {
                     if (e.hash == hash &&
                         ((k = e.key) == key ||
                          (key != null && key.equals(k)))) {
                         node = e;
                         break;
                     }
                     p = e;
                 } while ((e = e.next) != null);
             }
         }
         if (node != null && (!matchValue || (v = node.value) == value ||
                              (value != null && value.equals(v)))) {
             if (node instanceof TreeNode)
                 ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
             else if (node == p)
                 tab[index] = node.next;
             else
                 p.next = node.next;
             ++modCount;
             --size;
             afterNodeRemoval(node);
             return node;
         }
     }
     return null;
 }
```

- get

```java
public V get(Object key) {
    Node<K,V> e;
    if ((e = getNode(hash(key), key)) == null)
        return null;
    if (accessOrder)
        afterNodeAccess(e);
    return e.value;
}


final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (first = tab[(n - 1) & hash]) != null) {
        // 通过hash先查找到链表，也算提高效率，如果是只有链表，那么就需要整个链表遍历
        // 这里的first指的是，table中链表的第一个元素
        if (first.hash == hash && // always check first node
            ((k = first.key) == key || (key != null && key.equals(k))))
            return first;
        if ((e = first.next) != null) {
            if (first instanceof TreeNode)
                // 树化了的，则调用树查询方法
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            do {
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
                // 否则遍历链表查找
            } while ((e = e.next) != null);
        }
    }
    return null;
}
```

## 9. Hashtable

### 9.1 和HashMap比较

|           | 版本 |          线程安全           | 效率 | 底层数据结构             |                    null值                    |
| :-------: | :--: | :-------------------------: | :--: | ------------------------ | :------------------------------------------: |
|  HashMap  | 1.2  |           不安全            |  高  | 数组+链表+红黑树（jdk8） |                     允许                     |
| Hashtable | 1.0  | 安全(推荐ConcurrentHashMap) | 较低 | 数组+链表                | 不允许null的key和value(NullPointerException) |

### 9.2 源码解读

- 默认大小 11,扩容因子0.75

```java
public Hashtable() {
    this(11, 0.75f);
}

public Hashtable(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal Load: "+loadFactor);

    if (initialCapacity==0)
        initialCapacity = 1;
    this.loadFactor = loadFactor;
    table = new Entry<?,?>[initialCapacity];
    threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
}
```

- put操作

```java
// synchronized保证线程安全，但锁的太多逻辑了，导致性能下降比较多
public synchronized V put(K key, V value) {
    // Make sure the value is not null
    if (value == null) {
        // value不准为空，否则抛出异常
        throw new NullPointerException();
    }

    // Makes sure the key is not already in the hashtable.
    Entry<?,?> tab[] = table;
    // hash直接等于hashCode()
    int hash = key.hashCode();
    // Integer.MAX_VALUE=0x7FFFFFFF
    // 为什么不用(hash & 0x7FFFFFFF) & (tab.length - 1)?
    // 因为table.lenth长度不为2的幂次方，因此无法套用公式
    int index = (hash & 0x7FFFFFFF) % tab.length;
    @SuppressWarnings("unchecked")
    Entry<K,V> entry = (Entry<K,V>)tab[index];
    // 只有entry.next，因为Hashtbale没有树，只有链表
    for(; entry != null ; entry = entry.next) {
        // 判断相同，比较的是Entry的hash而不是key的hash
        if ((entry.hash == hash) && entry.key.equals(key)) {
            // 条件符合，替换value，自己直接return
            V old = entry.value;
            entry.value = value;
            return old;
        }
    }
	// 真正的添加逻辑
    addEntry(hash, key, value, index);
    return null;
}

 private void addEntry(int hash, K key, V value, int index) {
     modCount++;

     Entry<?,?> tab[] = table;
     // 达到临界值，执行扩容
     if (count >= threshold) {
         // Rehash the table if the threshold is exceeded
         rehash();

         tab = table;
         hash = key.hashCode();
         index = (hash & 0x7FFFFFFF) % tab.length;
     }

     // Creates the new entry.
     @SuppressWarnings("unchecked")
     Entry<K,V> e = (Entry<K,V>) tab[index];
     tab[index] = new Entry<>(hash, key, value, e);
     count++;
 }

protected Entry(int hash, K key, V value, Entry<K,V> next) {
    this.hash = hash;
    this.key =  key;
    this.value = value;
    // 加到头部
    this.next = next;
}
```

- 扩容： old * 2 + 1   （临界值为newCapacity * loadFactor）

```java
protected void rehash() {
    int oldCapacity = table.length;
    Entry<?,?>[] oldMap = table;

    // overflow-conscious code
    // 扩容： old * 2 + 1
    int newCapacity = (oldCapacity << 1) + 1;
    if (newCapacity - MAX_ARRAY_SIZE > 0) {
        if (oldCapacity == MAX_ARRAY_SIZE)
            // Keep running with MAX_ARRAY_SIZE buckets
            return;
        newCapacity = MAX_ARRAY_SIZE;
    }
    Entry<?,?>[] newMap = new Entry<?,?>[newCapacity];

    modCount++;
    threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
    table = newMap;
	// 拷贝数据
    for (int i = oldCapacity ; i-- > 0 ;) {
        for (Entry<K,V> old = (Entry<K,V>)oldMap[i] ; old != null ; ) {
            Entry<K,V> e = old;
            old = old.next;

            int index = (e.hash & 0x7FFFFFFF) % newCapacity;
            e.next = (Entry<K,V>)newMap[index];
            newMap[index] = e;
        }
    }
}
```

## 10. Properties

- 继承Hashtable
- 用IO读取properties文件

## 11. TreeSet : 有序set

- 底层是TreeMap

```java
public TreeSet() {
    this(new TreeMap<E,Object>());
}

public TreeMap() {
    comparator = null;
}

public TreeMap(Comparator<? super K> comparator) {
    this.comparator = comparator;
}

static final class Entry<K,V> implements Map.Entry<K,V> {
    K key;
    V value;
    Entry<K,V> left;
    Entry<K,V> right;
    Entry<K,V> parent;
    boolean color = BLACK;
}
```

## 12. TreeMap：有序Map	

### 12.2 源码解读

- put操作

```java
public V put(K key, V value) {
    Entry<K,V> t = root;
    // t==null说明是首次添加
    if (t == null) {
        compare(key, key); // type (and possibly null) check

        root = new Entry<>(key, value, null);
        size = 1;
        modCount++;
        return null;
    }
    int cmp;
    Entry<K,V> parent;
    // split comparator and comparable paths
    Comparator<? super K> cpr = comparator;
    if (cpr != null) {
        // 循环遍历
        do {
            parent = t;
            // 比较，t实际上是指针，根据cmp的正负，选择往左往右移动
            cmp = cpr.compare(key, t.key);
            if (cmp < 0)
                t = t.left;
            else if (cmp > 0)
                t = t.right;
            else
                // 相同则修改value
                return t.setValue(value);
        } while (t != null);
    }
    else {
        if (key == null)
            throw new NullPointerException();
        @SuppressWarnings("unchecked")
        // 构造方法没有传入比较器的话，则使用泛型对象来比较，因此如果泛型对象没有实现Comparable，就会转换异常。ClassCastException。否则和上面逻辑一样。
        Comparable<? super K> k = (Comparable<? super K>) key;
        do {
            parent = t;
            cmp = k.compareTo(t.key);
            if (cmp < 0)
                t = t.left;
            else if (cmp > 0)
                t = t.right;
            else
                return t.setValue(value);
        } while (t != null);
    }
    Entry<K,V> e = new Entry<>(key, value, parent);
    // 跳出上面while循环，parent为e所接近的对象，根据cmp的大小，选择放在左还是右
    if (cmp < 0)
        parent.left = e;
    else
        parent.right = e;
    fixAfterInsertion(e);
    size++;
    modCount++;
    return null;
}

final int compare(Object k1, Object k2) {
    return comparator==null ? ((Comparable<? super K>)k1).compareTo((K)k2)
        : comparator.compare((K)k1, (K)k2);
}

// 红黑树修正
private void fixAfterInsertion(Entry<K,V> x) {
    x.color = RED;

    while (x != null && x != root && x.parent.color == RED) {
        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
            Entry<K,V> y = rightOf(parentOf(parentOf(x)));
            if (colorOf(y) == RED) {
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else {
                if (x == rightOf(parentOf(x))) {
                    x = parentOf(x);
                    rotateLeft(x);
                }
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                rotateRight(parentOf(parentOf(x)));
            }
        } else {
            Entry<K,V> y = leftOf(parentOf(parentOf(x)));
            if (colorOf(y) == RED) {
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else {
                if (x == leftOf(parentOf(x))) {
                    x = parentOf(x);
                    rotateRight(x);
                }
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                rotateLeft(parentOf(parentOf(x)));
            }
        }
    }
    root.color = BLACK;
}
```

- ClassCastException:  泛型对象没有实现Comparable并且构造方法没有传入比较器

```java
 else {
     if (key == null)
         throw new NullPointerException();
     @SuppressWarnings("unchecked")
     // 构造方法没有传入比较器的话，则使用泛型对象来比较，因此如果泛型对象没有实现Comparable，就会转换异常。ClassCastException。否则和上面逻辑一样。
     Comparable<? super K> k = (Comparable<? super K>) key;
     do {
         parent = t;
         cmp = k.compareTo(t.key);
         if (cmp < 0)
             t = t.left;
         else if (cmp > 0)
             t = t.right;
         else
             return t.setValue(value);
     } while (t != null);
 }
```

## 13. 红黑树

讲的很棒 https://blog.csdn.net/chen_zhang_yu/article/details/52415077?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2

### 13.1 二叉搜索树：

左边的节点总是小于右边的节点的二叉树

**二叉搜索树从上投影是有序的** 

![1621517969401](E:\SoftwareNote\面试准备\数据结构\img\二叉搜索树从上投影是有序的.png)

- 二叉搜索树的遍历（命名规则：根在前中后）
  - **中序遍历**： 左 ->**根**-> 右 ,遍历出来时有序的
  - 前序遍历：**根** -> 左 -> 右
  - 后序遍历：左 -> 右 -> **根**

- 二叉搜索树找最大和最小值

  - 最小值： 一直left(),直至left.left=null
  - 最大值： 一直right(),直至right.right= null

- 二叉搜索树的删除

  - 没有子节点：删除树(即该子节点的父节点)对该子节点的引用
  - 1个子节点：该子节点的父节点指向该子节点的子节点
  - 2个子节点： 由该子节点的**后继节点（该子节点右侧的最小节点[如果不用最小节点，那么右侧还需要移动到新节点的左侧，工作量巨大]）**补上。

- **另一种删除思路：逻辑删除**

  删除需要移动树，因此可以增加一个删除属性，在查询前都多增加一个是否删除判断即可。

- 二叉搜索树和数组/链表比较

  - 数组的高效查询算法有二分查找，但是依赖数组有序，而且插入(一堆元素需要后移)和扩容都麻烦
  - 链表则是不好遍历
  - 二分查找树则是查找新增都很方便

- 二叉搜索树的致命缺陷：畸形树

  如果二叉搜索树的元素全部堆积在一边，那么树就退化成链表了，搜索效率变低

  因此需要解决二叉搜索树左右树的高度差尽量小，即左右自平衡（AVL）

![1621519950211](C:\Users\ASUS\AppData\Local\Temp\1621519950211.png)

### 13.2 AVL树（平衡树）

- AVL树 = 二叉搜索树 + 平衡左右树高度差不大于1（通过左旋/右旋控制）

- 为什么有AVＬ树还需要红黑树？

  AVL树虽然解决的二叉搜索树的致命缺点，但不是最佳解。因为条件太过苛刻(左右树高度差<=1)，

  这个要求导致几乎每次新增/删除操作都需要旋转树来调整符合该规则，从而使性能大打折扣

### 13.3 红黑树：黑色完美平衡(各链路黑点个数相同)

#### 13.3.1  红黑树的性质

- 每个节点要么是黑色，要么是红色

- **根节点是黑色**

- 每个叶子节点是黑色的

- 每个红色节点的子节点一定是黑色的，即**不能有2个红色节点相连（旋转的依据）**

- 任意节点到每个叶子节点的路径都包含数量相同的黑节点(**每条链路黑色数相同)，俗称黑高**！

  因此，如果一个黑节点有一个黑子节点，那么该黑节点一定有两个节点（左右都有节点）

![1621562825221](E:\SoftwareNote\面试准备\数据结构\img\红黑树的性质.png)

#### 13.3.2 黑色完美平衡

红黑树并不是一个完美平衡二叉树，左右树可能有大于1的高度差，但左右树的黑色节点数是相同的，即各个链路黑色节点个数是相同的。这种平衡称为黑色完美平衡。

#### 13.3.3 红黑树的自平衡

- 三大方式

  - **变色** ：

  - **左旋**：以某个节点E为旋转节点，把旋转节点E的右子节点S变成旋转节点E的父节点，再把右子节点S的左子树变成旋转节点的右子树

    即：S.left = E, E.parent=S; E.right=S.left

    ![1621562825221](E:\SoftwareNote\面试准备\数据结构\img\红黑树左旋.gif)

  - **右旋**：以某个节点S为旋转节点，把旋转节点S的左子节点E变成旋转节点S的父节点，再把左子节点E的右子节点变成旋转节点S的左子节点。

    即： E.right=S, S.parent=E; S.left=E.right

![1621562825221](E:\SoftwareNote\面试准备\数据结构\img\红黑树右旋.gif)

#### 13.3.4 红黑树的插入

插入操作主要分为两部分：

- 查找插入的位置，然后插入
- 自平衡操作

**注意**：

​	插入节点，必须为红色，因为红色再父节点（如果存在）为黑色节点时，**红黑色的黑色平衡没有被破坏**，无需做自平衡。 

​	如果插入黑色，那么黑色平衡遭到破坏，必须做自平衡。

#### 13.3.5 红黑树插入场景分析

1. 红黑树为空数：

   直接插入就好，但是根节点需要插入黑色。

2. 插入节点的key已存在：

   更新存在节点的value即可

3. 插入的节点的父节点为黑色：

   直接插入即可，因为插入节点为黑色，不影响平衡

4. **插入的节点父节点为红色（主要逻辑）** 

   4.1 叔叔节点(父的兄弟节点)也为红色

   ​	那么爷爷节点一定为黑色，因为不可能红红相连，而插入节点为红色，因此会变成黑红红。**最简单的做法**	

   ​	**就是变色，把爷爷节点变红，把父叔节点变黑，这样可以达到黑色完美平衡**。然后再处理爷爷节点(制成

   ​	当前节点)，处理爷爷节点主要**看爷爷的父节点是什么颜色**，如果是黑色不用管，**红色破坏了红红补相连**

   ​	**原则，需要按上述步骤(步骤4)重新处理爷爷节点(当前节点)** 

   ![1621522103363](E:\SoftwareNote\面试准备\数据结构\img\红黑树插入场景4.1.png)

   4.2 叔叔节点不存在或为黑色，并且插入的节点的父节点是爷爷节点的左子节点（即往爷爷左树插入）

   ​	4.2.1 插入节点为该节点的父节点的左子节点（LLr左左红）

   ​	1）变色：**父爷换色**

   ​	2）旋转：**以爷爷节点为支点进行右旋**

   ![1621522448525](E:\SoftwareNote\面试准备\数据结构\img\红黑树插入场景4.2.1LLr左左红.png)

   ​	4.2.2 插入节点为该节点的父节点的右子节点（LRr左右红）

   ​	1）左旋：**以父节点为支点左旋(设置原父节点为当前节点)**

   ​	2）然后就成了4.2.1，重复4.2.1即可（变色+右旋）

   ![1621522482217](E:\SoftwareNote\面试准备\数据结构\img\红黑树插入场景4.2.2LRr左右红.png)

   4.3 叔叔节点不存在或为黑色，并且插入的节点的父节点是爷爷节点的右子节点（即往爷爷右树插入），4.3其实是4.2反过来，逻辑左右处理相反即可。

   ​	4.3.1 插入节点为该节点的父节点的右子节点（RRr右右红）

   ​	1）变色：父爷换色

   ​	2）左旋：以爷爷节点为指点左旋

   ![1621522816908](E:\SoftwareNote\面试准备\数据结构\img\红黑树插入场景4.3.1RLr右左红.png)

   ​	4.3.2 插入节点为该节点的父节点的左子节点（RLr右左红）

   ​	1）右旋：以父节点为指点右旋

   ​	2）同4.3.1一样（换色+左旋）

   ![1621522992698](E:\SoftwareNote\面试准备\数据结构\img\红黑树插入场景4.3.2RRr右右红.png)

- 插入示意图

  ![1621523189811](E:\SoftwareNote\面试准备\数据结构\img\红黑树插入示意图.png)

#### 13.3.6 代码实现

- 代码层面分析

![1621559265799](E:\SoftwareNote\面试准备\数据结构\img\红黑树插入逻辑代码分析.png)

- 代码

```java
package com.codeman.RBTree;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * @author: zhanghongjie
 * @description: 红黑树
 * <p>
 * 1. 红黑树为空数：
 * 直接插入就好，但是根节点需要插入黑色。
 * 2. 插入节点的key已存在：
 * 更新存在节点的value即可
 * 3. 插入的节点的父节点为黑色：
 * 直接插入即可，因为插入节点为黑色，不影响平衡
 * 4. 插入的节点父节点为红色（主要逻辑）
 * 4.1 叔叔节点(父的兄弟节点)也为红色
 * 那么爷爷节点一定为黑色，因为不可能红红相连，而插入节点为红色，因此会变成黑红红。最简单的做法
 * 就是变色，把爷爷节点变红，把父叔节点变黑，这样可以达到黑色完美平衡。然后再处理爷爷节点(制成
 * 当前节点)，处理爷爷节点主要看爷爷的父节点是什么颜色，如果是黑色不用管，红色破坏了红红补相连
 * 原则，需要按上述步骤(步骤4)重新处理爷爷节点(当前节点)
 * 4.2 叔叔节点不存在或为黑色，并且插入的节点的父节点是爷爷节点的左子节点（即往爷爷左树插入）
 * 4.2.1 插入节点为该节点的父节点的左子节点（LLr左左红）
 * 1）变色：父爷换色
 * 2）旋转：以爷爷节点为支点进行右旋
 * 4.2.2 插入节点为该节点的父节点的右子节点（LRr左右红）
 * 1）左旋：以父节点为支点左旋(设置原父节点为当前节点)
 * 2）然后就成了4.2.1，重复4.2.1即可（变色+右旋）
 * <p>
 * 4.3 叔叔节点不存在或为黑色，并且插入的节点的父节点是爷爷节点的右子节点（即往爷爷右树插入），
 * 步骤4.3其实是4.2反过来，逻辑左右处理相反即可。
 * 4.3.1 插入节点为该节点的父节点的左子节点（RLr左左红）
 * 1）变色：父爷换色
 * 2）左旋：以爷爷节点为指点左旋
 * 4.3.2 插入节点为该节点的父节点的右子节点（RRr左左红）
 * 1）右旋：以父节点为指点右旋
 * 2）同4.3.1一样（换色+左旋）
 * @date: 2021/5/21 9:46
 * @version: 1.0
 */
public class RBTree<K extends Comparable, V> {

    /**
     * 树根
     */
    private BRNode<K, V> root;


    /**
     * 添加操作
     *
     * @param key
     * @param value
     */
    public void put(K key, V value) {
        if (root == null) {
            root = new BRNode<>(key, value);
            root.setColor(BRNodeColor.BLACK);
        } else {
            // 比较添加
            BRNode<K, V> newNode = onlyPut(key, value);
            // 自平衡
            autoBalance(newNode);

        }
    }

    /**
     * 自平衡
     * 1. 红黑树为空数：
     * 直接插入就好，但是根节点需要插入黑色。
     * 2. 插入节点的key已存在：
     * 更新存在节点的value即可
     * 3. 插入的节点的父节点为黑色：
     * 直接插入即可，因为插入节点为黑色，不影响平衡
     * 4. 插入的节点父节点为红色（主要逻辑）
     * 4.1 叔叔节点(父的兄弟节点)也为红色
     * 那么爷爷节点一定为黑色，因为不可能红红相连，而插入节点为红色，因此会变成黑红红。最简单的做法
     * 就是变色，把爷爷节点变红，把父叔节点变黑，这样可以达到黑色完美平衡。然后再处理爷爷节点(制成
     * 当前节点)，处理爷爷节点主要看爷爷的父节点是什么颜色，如果是黑色不用管，红色破坏了红红补相连
     * 原则，需要按上述步骤(步骤4)重新处理爷爷节点(当前节点)
     * 4.2 叔叔节点不存在或为黑色，并且插入的节点的父节点是爷爷节点的左子节点（即往爷爷左树插入）
     * 4.2.1 插入节点为该节点的父节点的左子节点（LLr左左红）
     * 1）变色：父爷换色
     * 2）旋转：以爷爷节点为支点进行右旋
     * 4.2.2 插入节点为该节点的父节点的右子节点（LRr左右红）
     * 1）左旋：以父节点为支点左旋(设置原父节点为当前节点)
     * 2）然后就成了4.2.1，重复4.2.1即可（变色+右旋）
     * <p>
     * 4.3 叔叔节点不存在或为黑色，并且插入的节点的父节点是爷爷节点的右子节点（即往爷爷右树插入），
     * 步骤4.3其实是4.2反过来，逻辑左右处理相反即可。
     * 4.3.1 插入节点为该节点的父节点的左子节点（RLr左左红）
     * 1）变色：父爷换色
     * 2）左旋：以爷爷节点为指点左旋
     * 4.3.2 插入节点为该节点的父节点的右子节点（RRr左左红）
     * 1）右旋：以父节点为指点右旋
     * 2）同4.3.1一样（换色+左旋）
     * @param newNode
     */
    private void autoBalance(BRNode<K, V> newNode) {
        // 1 和 2在onlyPut已经做了
        if (newNode != null) {
            // 3. 插入的节点的父节点为黑色：
            //  直接插入即可，因为插入节点为黑色，不影响平衡
            BRNode<K, V> parent = newNode.parent;
            if (parent != null) {
                // 红色才需要自平衡，因为不能双红
                if (parent.color == BRNodeColor.RED) {
                    // 4. 插入的节点父节点为红色（主要逻辑）
                    // 4.1 叔叔节点(父的兄弟节点)也为红色
                    // 那么爷爷节点一定为黑色，因为不可能红红相连，而插入节点为红色，因此会变成黑红红。最简单的做法
                    // 就是变色，把爷爷节点变红，把父叔节点变黑，这样可以达到黑色完美平衡。然后再处理爷爷节点(制成
                    // 当前节点)，处理爷爷节点主要看爷爷的父节点是什么颜色，如果是黑色不用管，红色破坏了红红补相连
                    // 原则，需要按上述步骤(步骤4)重新处理爷爷节点(当前节点)
                    BRNode<K, V> gPar = parent.parent;
                    if (gPar == null) {
                        if (parent.left == newNode) {
                            // 右旋
                            rightRotate(parent);
                        } else {
                            leftRotate(parent);
                        }
                        return;
                    }
                    if ((gPar.left != null && gPar.right != null) && gPar.left.color == gPar.right.color) {
                        // 父/叔节点都为红色
                        // 变色
                        gPar.left.color = gPar.right.color = BRNodeColor.BLACK;
                        gPar.setColor(BRNodeColor.RED);
                    } else {
                        if (gPar.left == parent) {
                            // 4.2 叔叔节点不存在或为黑色，并且插入的节点的父节点是爷爷节点的左子节点（即往爷爷左树插入）
                            if (parent.right == newNode) {
                                // 4.2.2 插入节点为该节点的父节点的右子节点（LRr左右红）
                                // 1）左旋：以父节点为支点左旋(设置原父节点为当前节点)
                                leftRotate(parent);
                                // newNode = parent;
                            }
                            // 2）然后就成了4.2.1，重复4.2.1即可（变色+右旋）

                            // 4.2.1 插入节点为该节点的父节点的左子节点（LLr左左红）
                            // 1）变色：父爷换色
                            gPar.setColor(BRNodeColor.RED);
                            // 不能用parent，因为parent已经变色
                            gPar.left.setColor(BRNodeColor.BLACK);
                            // 2）旋转：以爷爷节点为支点进行右旋
                            rightRotate(gPar);
                        } else {
                            // 4.3 叔叔节点不存在或为黑色，并且插入的节点的父节点是爷爷节点的右子节点（即往爷爷右树插入），

                            if (parent.left == newNode) {
                                // 4.3.2 插入节点为该节点的父节点的左子节点（RLr右左红）
                                // 1）右旋：以父节点为指点右旋
                                rightRotate(parent);
                            }

                            // 2）同4.3.1一样（换色+左旋）

                            // 步骤4.3其实是4.2反过来，逻辑左右处理相反即可。
                            // 4.3.1 插入节点为该节点的父节点的右子节点（RRr右右红）
                            // 1）变色：父爷换色
                            gPar.setColor(BRNodeColor.RED);
                            // 不能用parent，因为parent已经变色
                            gPar.right.setColor(BRNodeColor.BLACK);
                            // 2）左旋：以爷爷节点为指点左旋
                            leftRotate(gPar);
                        }

                    }
                    // 以爷爷节点为当前节点，继续重复（递归）
                    if (gPar.parent != null) {
                        autoBalance(gPar);
                    } else {
                        if (gPar.left == parent) {
                            rightRotate(gPar);
                        } else {
                            leftRotate(gPar);
                        }
                    }

                }
            } else {
                // 重置root
                root = newNode;
            }
        }

    }

    /**
     * 右旋
     *        A
     *
     *     B     E
     *
     * C      (D)
     *
     *
     * @param node
     */
    private void rightRotate(BRNode<K, V> node) {
        if (node != null) {
            BRNode<K, V> oldLeft = node.left;
            BRNode<K, V> oldParent = node.parent;
            if (oldLeft != null) {
                if (oldLeft.right != null) {
                    oldLeft.right.parent = node;
                }
                node.left = oldLeft.right;
                oldLeft.right = node;
                node.parent = oldLeft;
                if (oldParent != null) {
                    oldLeft.parent = oldParent;
                    if (oldParent.left == node) {
                        oldParent.left = oldLeft;
                    } else {
                        oldParent.right = oldLeft;
                    }
                } else {
                    // 改root
                    oldLeft.parent = null;
                    root = oldLeft;
                }
            }
        }
    }

    /**
     * 左旋
     *        A
     *
     *     B      E
     *
     *        (D)      F
     * @param node
     */
    private void leftRotate(BRNode<K, V> node) {
        if (node != null) {
            BRNode<K, V> oldRight = node.right;
            BRNode<K, V> oldParent = node.parent;
            if (oldRight != null) {
                node.right = oldRight.left;
                if (oldRight.left != null) {
                    oldRight.left.parent = node;
                }
                oldRight.left = node;
                node.parent = oldRight;

                if (oldParent != null) {
                    oldRight.parent = oldParent;
                    if (oldParent.left == node) {
                        oldParent.left = oldRight;
                    } else {
                        oldParent.right = oldRight;
                    }
                } else {
                    // 改root
                    oldRight.parent = null;
                    root = oldRight;
                }
            }
        }
    }

    /**
     * 只做比较插入
     * @param key
     * @param value
     */
    private BRNode<K, V> onlyPut(K key, V value) {
        BRNode<K, V> temp = root;
        while (true) {
            if (temp.key.compareTo(key) == 0) {
                // 相同则替换值
                temp.setValue(value);
                return temp;
            } else if (temp.key.compareTo(key) > 0) {
                if (temp.left == null) {
                    temp.left = new BRNode<>(key, value);
                    temp.left.setColor(BRNodeColor.RED);
                    temp.left.setParent(temp);
                    return temp.left;
                }
                // 小于则往左比较
                temp = temp.left;

            } else {
                if (temp.right == null) {
                    temp.right = new BRNode<>(key, value);
                    temp.right.setColor(BRNodeColor.RED);
                    temp.right.setParent(temp);
                    return temp.right;
                }
                // 大于则往右比较
                temp = temp.right;
            }
        }
    }


    /**
     * 获取最大值
     *
     * @return
     */
    public BREntity<K, V> getMax() {
        if (root != null) {
            BRNode<K, V> last = root;
            while (last.right != null) {
                last = last.right;
            }
            return new BREntity<>(last.key, last.value);
        }
        return null;
    }

    /**
     * 获取最小值
     *
     * @return
     */
    public BREntity<K, V> getMin() {
        if (root != null) {
            BRNode<K, V> first = root;
            while (first.left != null) {
                first = first.left;
            }
            return new BREntity<>(first.key, first.value);
        }
        return null;
    }

    /**
     * 中序遍历方法
     */
    public BREntity[] trans2MidEntiryArr() {
        List<BREntity> brEntityList = new ArrayList<>();
        doTrans2MidEntiryArr(root, brEntityList);
        return brEntityList.toArray(new BREntity[]{});
    }

    /**
     * 中序遍历：前 -> 中 -> 后
     * 要找到最前，可以用遍历
     *
     * @param node
     * @param brEntityList
     */
    private void doTrans2MidEntiryArr(BRNode<K, V> node, List<BREntity> brEntityList) {
        if (node != null) {
            // 左边递归
            doTrans2MidEntiryArr(node.left, brEntityList);
            // 左边递归直至node.left为空，然后开始封装对象
            brEntityList.add(transNode2Entity(node));
            // 封装完，递归右树
            doTrans2MidEntiryArr(node.right, brEntityList);
        }
    }

    private BREntity<K, V> transNode2Entity(BRNode<K, V> node) {
        return new BREntity<>(node.key, node.value);
    }

    /**
     * 对外暴露的key-value映射
     */
    public class BREntity<K, V> {
        K key;
        V value;

        public BREntity(K key, V value) {
            this.key = key;
            this.value = value;
        }

        public K getKey() {
            return key;
        }

        public void setKey(K key) {
            this.key = key;
        }

        public V getValue() {
            return value;
        }

        public void setValue(V value) {
            this.value = value;
        }

        @Override
        public String toString() {
            return "[" +key + "]";
        }
    }


    /**
     * 树需要一个节点
     * 节点需要属性：
     * key/value/color/left/right/parent
     */
    private class BRNode<K, V> {
        K key;
        V value;
        BRNodeColor color;
        BRNode<K, V> parent, left, right;

        public BRNode(K key, V value) {
            this.key = key;
            this.value = value;
        }

        public void setKey(K key) {
            this.key = key;
        }

        public void setValue(V value) {
            this.value = value;
        }

        public void setColor(BRNodeColor color) {
            this.color = color;
        }

        public void setParent(BRNode<K, V> parent) {
            this.parent = parent;
        }

        public void setLeft(BRNode<K, V> left) {
            this.left = left;
        }

        public void setRight(BRNode<K, V> right) {
            this.right = right;
        }
    }

    /**
     * 节点颜色
     */
    private enum BRNodeColor {
        RED, BLACK
    }

}

```

















































![1621518701303](C:\Users\ASUS\AppData\Local\Temp\1621518701303.png)