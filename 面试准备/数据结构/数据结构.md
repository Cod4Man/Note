# 数据结构

![1619362580681](E:\SoftwareNote\面试准备\数据结构\img\数据结构.png)

## 1.一些知识点

### 1.1 增强for (T t : Collection) 底层也是iterator遍历

## 2. ArrayList

### 2.1 扩容机制

```java
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; // {} 默认空
}

public ArrayList(int initialCapacity) {
    if (initialCapacity > 0) {
        // 创建一个
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        // 空{}
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    }
}


public boolean add(E e) {
    // 扩容判断处理，当前长度+1
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    // 增加元素
    elementData[size++] = e;
    return true;
}

private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        // DEFAULT_CAPACITY = 10
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }

    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // overflow-conscious code
    // 所需的容量 > 原数组长度，则需要扩容
    if (minCapacity - elementData.length > 0)
        // 真正扩容逻辑
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    // 这里可以看出扩容是在原基础上扩1.5倍
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    // 当old=0时，new也为0，所以会进下面逻辑为new赋新值，而不是上面的1.5倍扩容
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    // Arrays.copyOf() 可以保留原来的数据
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

## 3. Vector

### 3.1 Vector和ArrayList比较

- Vector线程安全/效率低，ArrayList反之。
- 扩容倍数：vector为2倍，ArrayList为1.5

### 3.2 扩容机制

```java
public Vector() {
    // 无参构造，默认长度10
    this(10);
}

public Vector(int initialCapacity) {
    this(initialCapacity, 0);
}

// capacityIncrement构造方法可指定扩容大小。无指定则为2倍
public Vector(int initialCapacity, int capacityIncrement) {
    super();
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    this.elementData = new Object[initialCapacity];
    this.capacityIncrement = capacityIncrement;
}

public synchronized boolean add(E e) {
    modCount++;
    // 尝试扩容，当前长度+1
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}

private void ensureCapacityHelper(int minCapacity) {
    // overflow-conscious code
    // 判断是否需要扩容
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    // capacityIncrement构造方法传入的扩容数，没传则为0
    // 无capacityIncrement构造，扩容为oldCapacity+oldCapacity，2倍扩容
    // 有capacityIncrement构造，扩容为oldCapacity+capacityIncrement
    int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                     capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

## 4. LinkedList

### 4.1是双向链表

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

### 4.2 LinkedList和ArrayList对比

- 底层结构：ArrayList底层是可变数组，LinkedList底层是双向链表
- 效率: ArrayList查询/修改快，LinkedList增删快

### 4.3 add(E)

```java
public boolean add(E e) {
    linkLast(e);
    return true;
}

void linkLast(E e) {
    final Node<E> l = last;
    // e.pre = l
    final Node<E> newNode = new Node<>(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        // l.next = e   , 加上上面的就是双向指向了
        l.next = newNode;
    size++;
    modCount++;
}
```

### 4.4 add(index, E)

```java
public void add(int index, E element) {
    checkPositionIndex(index);

    if (index == size)
        linkLast(element);
    else
        linkBefore(element, node(index));
}

Node<E> node(int index) {
    // assert isElementIndex(index);

    if (index < (size >> 1)) {
        Node<E> x = first;
        for (int i = 0; i < index; i++)
            x = x.next;
        return x;
    } else {
        Node<E> x = last;
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x;
    }
}

void linkBefore(E e, Node<E> succ) {
    // assert succ != null;
    final Node<E> pred = succ.prev;
    final Node<E> newNode = new Node<>(pred, e, succ);
    succ.prev = newNode;
    if (pred == null)
        first = newNode;
    else
        pred.next = newNode;
    size++;
    modCount++;
}
```

### 4.5 remove(index)

```java
public E remove(int index) {
    checkElementIndex(index);
    return unlink(node(index));
}
E unlink(Node<E> x) {
    // assert x != null;
    final E element = x.item;
    final Node<E> next = x.next;
    final Node<E> prev = x.prev;

    if (prev == null) {
        first = next;
    } else {
        prev.next = next;
        x.prev = null;
    }

    if (next == null) {
        last = prev;
    } else {
        next.prev = prev;
        x.next = null;
    }

    x.item = null;
    size--;
    modCount++;
    return element;
}
```

## 5. HashSet

- 底层是HashMap

```java
public HashSet() {
    map = new HashMap<>();
}
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
```

## 6. HashMap

### 6.1 底层

- 底层是数组+链表+红黑树

- 添加流程：
  - 先得到Key的hash值（转换为索引值）
  - 在存储数据表table中，查看该索引位置是否有存值
  - 没有则直接加入
  - 有则调用equals方法依次与该索引中的其他元素比较，相同则放弃添加，不同则添加到最后
  - 在JAVA8中，如果一条链表的元素个数(TREEIFY_THRESHOLD)到达8个(默认)，并且数据表table中的大小>=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树)

- 扩容resize

  - 扩容：计算出新长度size和新临界值threshold

  - 扩容规则：

    1.0 首次扩容
    	newCap = DEFAULT_INITIAL_CAPACITY(1 << 4）= 16
            newThr = (int)(DEFAULT_LOAD_FACTOR(0.75f) * DEFAULT_INITIAL_CAPACITY(1 << 4）); = 12
    1.1. oldSize > MAXIMUM_CAPACITY(1<<30) ,临界值threshold = Integer.MAX_VALUE，不再扩容
    1.2. newCap和newThr各扩容一倍（size<1）

  - 从老数据拷贝到新数据中Node[]

  - 
     put方法一共有三处地方扩容：
          // 1.put的时候发现超过临界值
          // 2. 首次put
          // 3. 调用树化方法时，发现table.length还未达到MIN_TREEIFY_CAPACITY(64)

- 树化（红黑树）treeifyBin，满足以下条件

  A. 如果链表的长度>=TREEIFY_THRESHOLD - 1=7,即链表达到8长度，那么则进入树化方法，但是还需判断B
  B. 方法内部隐藏条件，table长度>=64。如果<64，那么不会树化，而是执行resize扩容

### 6.2 源码解读

- HashSet底层是HashMap

```java
public HashSet() {
    map = new HashMap<>();
}
```

- add 调用的是HashMap的put，而value为final空对象

```java
private static final Object PRESENT = new Object();
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
```

- hashMap.put

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

// 可以看出，HashMap.hash并不是Object.hash，而是特殊处理过的
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        // table=null说明是首次创建add，要先执行resize()方法初始化table
        n = (tab = resize()).length;
    // (n - 1) & hash即 hash % n, 该key的hash模table长度，为存放位置
    if ((p = tab[i = (n - 1) & hash]) == null)
        // 该位置如果没人，则直接占着
        tab[i] = newNode(hash, key, value, null);
    else {
        // 该位置有人，则需要分情况考虑
        Node<K,V> e; K k;
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            // 如果hash相同并且（==或则equals相同），那么无需插入
            // 看到判断条件，可以得知如果某对象想改造成HashMap.put唯一，则需要重写hash和equals方法
            // 所以String对象，不同对象，字符串相同也算同一个对象，因为String重写了hash和equals
            e = p;
        else if (p instanceof TreeNode)
            // 如果该位置为TreeNode（Node的子类），说明该链表已经树化过了，直接调用TreeNode的
            // putTreeVal方法进行赋值
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            // 如果有人，并且上述2个条件都不符合，则插入到链路的最后
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        // 如果链表的长度>=TREEIFY_THRESHOLD - 1=7,即链表达到8长度，那么则进入树化
                        // 方法内部隐藏条件，table长度>=64
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    // 如果链路中的某对象和条件1一样，说明是同一个对象。那么也直接返回，无需插入
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    // put的时候size会+1,注意该size不是table的size，table是一个数组Node[]，该size>=table.length,因为Node是链表，里面的元素也累加size
    if (++size > threshold)
        // 当size超过临界值，则进行扩容，所以扩容是在临界值提前扩容，而不是用完才扩容
        // put方法一共有三处地方扩容：
        // 1.put的时候发现超过临界值
        // 2. 首次put
        // 3. 调用树化方法时，发现table.length还未达到MIN_TREEIFY_CAPACITY(64)
        resize();
    // 这是个空实现，可以流程子类做特殊处理，如LinkedHashMap
    afterNodeInsertion(evict);
    return null;
}


/**
1. 扩容：计算出新长度size和新临界值threshold
	扩容规则：
	1.0 首次扩容
		newCap = DEFAULT_INITIAL_CAPACITY(1 << 4）= 16
        newThr = (int)(DEFAULT_LOAD_FACTOR(0.75f) * DEFAULT_INITIAL_CAPACITY(1 << 4）); = 12
	1.1. oldSize > MAXIMUM_CAPACITY(1<<30) ,临界值threshold = Integer.MAX_VALUE，不再扩容
	1.2. newCap和newThr各扩容一倍（size<1）
2. 从老数据拷贝到新数据中Node[]
3. 
		// put方法一共有三处地方扩容：
        // 1.put的时候发现超过临界值
        // 2. 首次put
        // 3. 调用树化方法时，发现table.length还未达到MIN_TREEIFY_CAPACITY(64)
*/
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap > 0) {
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                 oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
    }
    else if (oldThr > 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else {               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    // 拷贝老数据到新数据 oldTab -> newTab(即table)
    if (oldTab != null) {
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash & (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                else { // preserve order
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    do {
                        next = e.next;
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}

/**
树化链表 Node -> TreeNode
*/
final void treeifyBin(Node<K,V>[] tab, int hash) {
    int n, index; Node<K,V> e;
    
    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
        resize();
    else if ((e = tab[index = (n - 1) & hash]) != null) {
        //  n = tab.length) < MIN_TREEIFY_CAPACITY=64 隐藏条件，table长度>=64
        TreeNode<K,V> hd = null, tl = null;
        do {
            TreeNode<K,V> p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}

```

